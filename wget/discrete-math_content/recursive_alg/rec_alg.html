
<html>
 
<body bgcolor="#ffffff" text="black" link="blue" vlink="#00bb77">
 
 
<title>Recursive Algorithm </title>
 
<H5><P align="Right">Recursive Definition</P></H5>

<center>
<h2>Recursive Algorithm </h2> 
</center>
<BR>
<BR>
<h3><font color="green">Subjects to be Learned </font></h3>
<UL>
<LI>solving problem with recursive algorithm
<LI>computing function with recursive algorithm
<LI>Checking set membership with recursive algorithm
</ul>
<h3><font color="green">Contents </font></h3>
A <font color="red"><B>recursive algorithm</B></font> 
is an algorithm which
calls itself with "smaller (or simpler)" input values, and which obtains the result for the current
input by applying simple operations to the returned value for the smaller (or simpler) input. 
More generally if a problem can be solved 
utilizing solutions to smaller
versions of the same problem, and the smaller versions reduce to easily solvable cases,
then one can use a recursive algorithm to solve that problem.
For example, the elements of a recursively defined set, or the value of a recursively defined function 
can be obtained by a recursive algorithm. 
<BR>
<BR>
If a set or a function is defined recursively, then a recursive algorithm to compute 
its members or values mirrors the definition. Initial steps of the recursive algorithm 
correspond to the basis clause of the recursive definition and they identify the basis elements.
They are then followed by 
steps corresponding to the inductive clause, which reduce the computation for an element
of one generation to that of 
elements of the immediately preceding generation.
<BR>
<BR>
In general, recursive computer programs require more memory and computation compared with iterative
algorithms, but they are simpler and for many cases a natural way of thinking about the problem.
<BR>
<BR>
<B>Example 1:</B> Algorithm for finding the <B><i>k</I></B>-th even natural number 
<BR>
Note here that this can be solved very easily by simply outputting <B><I>2</I>*(<I>k - 1</I>) </B>
for a given <B><I>k</I> .</B>
The purpose here, however, is to illustrate the basic idea of recursion rather than solving the problem.
<BR>
<BR>
<B>Algorithm 1: &nbsp; Even(</B>positive integer <B><I>k</I>)</B>
<BR>
<B>Input: <I>k</I></B> , a positive integer 
<BR>
<B>Output: <I>k</I></B>-th even natural number (the first even being <B><I>0</I></B>)
<BR>
<BR>
<B>Algorithm:</B>
<BR>
<B>if <I>k</I> = <I>1</I>,</B> <B>then</B> return <B><I>0</I>;</B> 
<BR>
<B>else</B> return <B>Even(<I>k-1</I>) + <I>2</I> .</B>
<BR>
<BR>
Here the computation of <B>Even(<I>k</I>)</B> is reduced to that of <B>Even</B> 
for a smaller input value, that is
<B>Even(<I>k-1</I>). Even(<I>k</I>)</B> eventually becomes <B>Even(<I>1</I>)</B> 
which is <B><I>0</I></B> by the first line. For example,
to compute <B>Even(<I>3</I>)</B>, <B>Algorithm</B> <B>Even(<I>k</I>)</B> is called with 
<B><I>k</I> = <I>2</I></B>. In the computation of <B>Even(<I>2</I>)</B>, <B>Algorithm</B> 
<B>Even(<I>k</I>)</B> is called with <B><I>k</I> = <I>1</I>. </B>
Since <B>Even(<I>1</I>) = <I>0, 0</I></B> is returned for the computation of 
<B>Even(<I>2</I>)</B>, and <B>Even(<I>2</I>)</B> = <B>Even(<I>1</I>) + <I>2</I> = <I>2
</I></B> is 
obtained. This value <B><I>2</I></B> for <B>Even(<I>2</I>)</B> is now returned to the computation of <B>Even(<I>3</I>)</B>, and <B>Even(<I>3</I>) = Even(<I>2</I>) + <I>2</I>
= <I>4</I></B> is obtained. 
<BR>
As can be seen by comparing this algorithm with the recursive definition of 
<a href="../recursive_def/rec_def.html#Even" target="main"><r>the set of
nonnegative even numbers</r></a>, the first line of the algorithm corresponds 
to the basis clause of the definition, and the second line corresponds 
to the inductive clause. 
<BR>
<BR>
By way of comparison, let us see how the same problem can be solved by an iterative algorithm.
<BR>
<BR>
<B>Algorithm 1-a: &nbsp; Even(</B>positive integer <B><I>k</I>)</B>
<BR>
<B>Input: <I>k</I></B>, a positive integer 
<BR>
<B>Output: <I>k</I></B>-th even natural number (the first even being <B><I>0</I></B>)
<BR>
<BR>
<B>Algorithm:</B>
<BR>
<B>int &nbsp; <I>i</I>, <I>even</I>; </B>
<BR>
<B><I>i</I> := <I>1</I>;</B><BR>
<B><I>even</I> := <I>0</I>;</B><BR>
<B>while( <I>i &lt; k</I> ) {</B>
<BR>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B><I>even</I> := <I>even</I> + <I>2</I>; </B>
<BR>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B><I>i</I> :=  <I>i</I> + <I>1</I>; </B>
<BR>
<B>}</B>
<BR>
return <B><I>even</I> .</B> <BR>

<BR>
<BR>
<B>Example 2:</B> Algorithm for computing the <B><I>k</I></B>-th power of 
<B><I>2</I></B> 
<BR>
<BR>
<B>Algorithm 2 &nbsp; Power_of_2(</B>natural number <B><I></I>k)</B>
<BR>
<B>Input: <I>k</I></B> , a natural number 
<BR>
<B>Output: <I>k</I></B>-th power of <B><I>2</I></B>
<BR>
<BR>
<B>Algorithm:</B>
<BR>
<B>if</B> <B><I>k</I> = <I>0</I></B>, <B>then</B> return <B><I>1</I></B>; 
<BR>
<B>else</B> return <B>2*Power_of_2(<I>k - 1</I>) .</B> 
<BR>
<BR>
By way of comparison, let us see how the same problem can be solved by an iterative algorithm.
<BR>
<BR>
<B>Algorithm 2-a &nbsp; Power_of_2(</B>natural number <B><I></I>k)</B>
<BR>
<B>Input: <I>k</I></B> , a natural number
<BR>
<B>Output: <I>k</I></B>-th power of <B><I>2</I></B>
<BR>
<BR>
<B>Algorithm:</B>
<BR>
<B>int &nbsp; <I>i</I>, <I>power</I>; </B>
<BR>
<B><I>i</I> := <I>0</I>;</B><BR>
<B><I>power</I> := <I>1</I>;</B><BR>
<B>while( <I>i &lt; k</I> ) {</B>
<BR>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B><I>power</I> := <I>power</I> * <I>2</I>; </B>
<BR>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B><I>i</I> :=  <I>i</I> + <I>1</I>; </B>
<BR>
<B>}</B>
<BR>
return <B><I>power</I> .</B> <BR>
<BR>
<BR>
The next example does not have any corresponding recursive definition.
It shows a recursive way of solving a problem.
<BR>
<BR>
<B>Example 3:</B> Recursive Algorithm for Sequential Search 
<BR>
<BR>
<B>Algorithm 3 &nbsp; SeqSearch(<I>L, i, j, x</I>) </B><BR>
<BR>
<B>Input:</B> 
<B><I>L</I></B> is an array, <B><I>i</I></B> and <B><I>j</I></B> are positive integers, <B><I>i</I></B> 
<B><img width="14" height="24" align="middle" src="../symbols_sets/leq.gif">
 </B>
 <B><I>j</I></B>, and <B><I>x</I></B> is the key 
to be searched for in <B><I>L</I></B>.
<BR>
<B>Output:</B> If <B><I>x</I></B> is in <B><I>L</I></B> between indexes <B><I>i</I></B> 
and <B><I>j</I></B>, then output its index, else output <B><I>0</I></B>.
<BR>
<BR>
<B>Algorithm:</B>
<BR>
<B>if</B>  <B><I>i</I></B> 
<B><img width="14" height="24" align="middle" src="../symbols_sets/leq.gif">
 </B>
 <B><I>j</I> ,</B> <B>then</B> 
<BR>
{
<BR>
 &nbsp;&nbsp;&nbsp;<B>if</B> <B><I>L</I>(<I>i</I>) = <I>x</I></B>, <B>then</B> return 
<B><I>i</I> ;</B>  
<BR>
 &nbsp;&nbsp;&nbsp;<B>else</B> return <B>SeqSearch(<I>L, i+1, j, x</I>)</B>
<BR>
}
<BR>
<B>else</B> return  <B><I>0</I>.
</B>
<BR>
<BR>
<BR>
Recursive algorithms can also be used to test objects for membership in a set.
<BR>
<BR>
<B>Example 4:</B> Algorithm for testing whether or not a number <B><i>x</I></B> is a natural number
<BR>
<BR>
<B>Algorithm 4 &nbsp; Natural(</B>a number <B><I>x</I>)</B>
<BR>
<B>Input:</B> A number <B><I>x</I></B>
<BR>
<B>Output:</B> "<B>Yes</B>" if <B><I>x</I></B> is a natural number, else "<B>No</B>"
<BR>
<BR>
<B>Algorithm:</B>
<BR>
<B>if <I>x</I> &lt; <I>0</I>,</B> &nbsp; <B>then</B> return "<B>No</B>"<B></B>
<BR>
<B>else</B> 
<BR>
&nbsp;&nbsp;&nbsp; <B>if <I>x</I> = <I>0</I>,</B> &nbsp; <B>then</B> return "<B>Yes</B>"<B></B>
<BR>
&nbsp;&nbsp;&nbsp; <B>else</B> return <B>Natural( <I>x - 1</I> )</B>
<BR>
<BR>
<B>Example 5:</B> Algorithm for testing whether or not an expression <B><i>w</I></B> is a proposition(propositional form)
<BR>
<BR>
<B>Algorithm 5 &nbsp; Proposition( </B>a string <B><i>w</I> )</B>
<BR>
<BR>
<B>Input:</B> A string <B><i>w</I></B>
<BR>
<B>Output:</B> "<B>Yes</B>" if <B><I>w</I></B> is a proposition, else "<B>No</B>"
<BR>
<BR>
<B>Algorithm:</B>
<BR>
<B>if <i>w</I></B> is <B><I>1</I></B>(true), <B><I>0</I></B>(false), <B>or</B> a propositional variable,
<B>then</B> return "<B>Yes</B>"
<BR>
<B>else if</B> <B><i>w</I> = ~<I>w<sub>1</sub></i></B>, <B>then</B> return 
<B>Proposition</B>(<I>w<sub>1</sub></i></B>)
<BR>
&nbsp;&nbsp; <B>else</B> 
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <B>if ( <I>w</I> = <I>w<sub>1</sub></i> 
<img src="../symbols_sets/or.gif"> <I>w<sub>2</sub></i> or 
<I>w<sub>1</sub></i> <img src="../symbols_sets/and.gif"> <I>w<sub>2</sub></i>
or
<I>w<sub>1</sub></i> <img src="../symbols_sets/imp.gif"> <I>w<sub>2</sub></i>
or
<I>w<sub>1</sub></i> <img src="../symbols_sets/eqv.gif"> <I>w<sub>2</sub></i> )
and </B>
<BR>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 
<B>Proposition</B>(<I>w<sub>1</sub></i></B>) = <B>Yes
and &nbsp; Proposition</B>(<I>w<sub>2</sub></i></B>) = <B>Yes</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; <B>then</B> return <B>Yes</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; <B>else</B> return <B>No</B> 
<BR>
<B>end</B> 
<br>
<br>
<br>
<br>
<br>
<br>
<h3><font color="green">Test Your Understanding of Recursive Algorithm </font></h3>
Indicate which of the following statements are correct and which are not.
<br>
Click Yes or No , then Submit. 
<br>
<br>
<br>
<applet code="exercise.class" width=750 height=650>
</applet>
<BR><BR>
<B><a href="../induction/induction.html"><r><font color="blue">
Next -- First Principle of Mathematical Induction </font></r></a></B>
<BR>
<BR>
<a href="../schedule/schedule.html#day15"><r><font color="blue">
Back to Schedule </font></r></a></B>
<BR>
<a href="../web_course.html"><r><font color="blue">
Back to Table of Contents </font></r></a></B>


</body>
</html>

