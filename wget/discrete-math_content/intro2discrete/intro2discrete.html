
<html>
<head>
<title> Introduction to Discrete Mathematics </title>
 
<!-- Written by: Toida, 2-June-1999 -->
<!-- Revised by: Toida , 10-01-2000  -->
 
</head>
 
<body bgcolor = "white">
 
<h2><p align="CENTER">Introduction to Discrete Structures --- Whats and Whys </p></h2>
<B>What is Discrete Mathematics ?</B>
<BR>
<BR>
Discrete mathematics is mathematics that deals with discrete objects.
Discrete objects are those which are separated from (not connected to/distinct 
from)
each other.
Integers (aka whole numbers), rational numbers (ones that can be 
expressed as the quotient of
two integers), automobiles, houses, people etc. are all discrete objects.
On the other hand real numbers which include irrational as well as rational numbers
are not discrete. As you know between any two different real numbers there
is another real number different from either of them. So they are packed without any
gaps and can not be separated from their immediate neighbors. In that sense
they are not discrete.
In this course we will be concerned with objects such as integers, propositions, 
sets, relations and functions, which are all discrete. We are going to learn concepts
associated with them, their properties, and relationships among them among others.

<BR><BR>
<B>Why Discrete Mathematics ?</B>
<BR>
<BR>
Let us first see why we want to be interested in the formal/theoretical approaches
in computer science.
<BR>
Some of the major reasons that we adopt formal approaches are
1) we can handle infinity or large quantity and indefiniteness with them, 
and 2) results from formal approaches are reusable. 
<BR>
<BR>
As an example, let us consider a simple problem of investment. Suppose that
we invest $1,000 every year with expected return of 10% a year.
How much are we going to have after 3 years, 5 years, or 10 years ?
The most naive way to find that out would be the brute force calculation.
<BR>
<BR>
Let us see what happens to $1,000 invested at the beginning of each year for three years.
<BR>
First let us consider the $1,000 invested at the beginning of the first year.
After one year it
produces a return of
$100. Thus at the beginning of the second year, $1,100, which is
equal to $1,000 * ( 1 + 0.1 ), is
invested. This $1,100 produces $110 at the end of the second year. Thus
at the beginning of the third year we have $1,210, which is equal to $1,000 * 
( 1 + 0.1 )( 1 + 0.1 ), or $1,000 * ( 1 + 0.1 )<SUP>2</sup>. 
After the third year this gives us $1,000 * ( 1 + 0.1 )<SUP>3</sup>.  
<BR>
<BR>
Similarly we can see that the $1,000 invested at the beginning of the second year
produces $1,000 * ( 1 + 0.1 )<SUP>2</sup> at the end of the third year, and
the $1,000 invested at the beginning of the third year becomes $1,000 * ( 1 + 0.1 ).
<BR><BR>
Thus the total principal and return after three years is
$1,000 * ( 1 + 0.1 ) + $1,000 * ( 1 + 0.1 )<SUP>2</sup> + $1,000 * ( 1 + 0.1 )<SUP>3</sup>,
which is equal to $3,641.
<BR>
<BR>
One can similarly calculate the principal and return for 5 years
and for 10 years. It is, however, a long tedious calculation even with 
calculators. Further, what if you want to know the principal and return for
some different returns than 10%, or different periods of time such as
15 years ?  You would have to do all these calculations all over again.
<BR>
<BR>
We can avoid these tedious calculations considerably by noting the similarities
in these problems and solving them in a more general way. 
<BR>Since all these problems ask for the result of invesing a certain amount 
every year for certain number of years with a certain expected annual return,
we use variables, say <B><I>A, R </I></B>and <B><I>n</I></B>, 
to represent the principal newly invested
every year, the return ratio, and the number of years invested, respectively.
With these symbols, the principal and return after <B><I>n</I></B> years, denoted by 
 <B><I>S</I></B>, can be expressed as
<BR>
 <B><I>S</I> = <I>A</I>(1 + <I>R</I>) + <I>A</I>(1 + <I>R</I>)<sup>2</sup> + ... +  <I>A</I>(1 + 
<I>R</I>)<sup><I>n</I></sup> .</B>
<BR>
As well known, this <B><I>S</I></B> can be put into a more compact form 
by first computing  <B><I>S</I> - (1 + <I>R</I>)<I>S</I>   </B> as
<BR>
 <B><I>S</I> = <I>A</I> ( (1 + <I>R</I>)<sup><I>n + 1</I></sup> - (1 + <I>R</I>) ) / <I>R</I> .</B>
<BR>
Once we have it in this compact form, it is fairly easy to compute  <B><I>S</I></B>
for different values of <B><I>A, R </I></B>and <B><I>n</I></B>, though
one still has to compute <B>(1 + <I>R</I>)<sup><I>n + 1</I></sup> .</B>
This simple formula represents infinitely many cases involving
all different values of <B><I>A, R </I></B>and <B><I>n</I>.</B>
The derivation of this formula, however, involves another problem. 
When computing the compact form for  <B><I>S</I></B>, 
&nbsp; <B><I>S</I> - (1 + <I>R</I>)<I>S</I></B>
&nbsp; was computed using 
&nbsp; <B><I>S</I> = <I>A</I>(1 + <I>R</I>) + <I>A</I>(1 + <I>R</I>)<sup>2</sup> + 
... +  <I>A</I>(1 +
<I>R</I>)<sup><I>n</I></sup> .</B>
While this argument seems rigorous enough, in fact practically it is a good enough
argument,
when one wishes to be very rigorous, the ellipsis <B>...</B> in the sum for
<B><I>S</I></B> is not considered precise. You are expected to interpret it
in a certain specific way. But it can be interpreted
in a number of different ways. In fact it can mean anything.
Thus if one wants to be rigorous, and absolutely sure about the correctness
of the formula, one needs some other way of verifying it than using the ellipsis.
Since one needs to verify it for infinitely many cases (infinitely many
values of <B><I>A, R </I></B>and <B><I>n</I></B>), some kind of
formal approach, abstracted away from actual numbers, is required.
  
<BR><BR>
Suppose now that somehow we have formally verified the formula successfully
and we are absolutely sure that it is correct. It is a good idea to write
a computer program to compute that <B><I>S</I></B>, especially with
<B>(1 + <I>R</I>)<sup><I>n + 1</I></sup> </B> &nbsp; to be computed.
Suppose again that we have written a program to compute <B><I>S</I></B>.
How can we know that the program is correct ? As we know, there are
infinitely many possible input values (that is, values of <B><I>A, R 
</I></B>and <B><I>n</I></B>).
Obviously we can not test it for infinitely many cases. Thus we must take 
some formal approach.

<BR><BR>
Related to the problem of correctness of computer programs, there is
the well known "Halting Problem". This problem, if put into the context of
program correctness, asks 
whether or not a given computer program stops 
on a given input
after a finite amount of time.
This problem is known to be unsolvable by computers. That is, no one
can write a computer program to answer that question.
It is known to be unsolvable. But, how can we tell it is unsolvable ?. 
How can we tell
that such a program can not be written ? You can not try all possible 
solution methods and see they all fail. You can not think of <B>all</B> (candidate) 
methods to solve the 
Halting Problem. Thus you need some kind of formal approaches here to avoid
dealing with a extremely large number (if not infinite) of possibilities.

<BR><BR>
Discrete mathematics is the foundation for the formal approaches.
It discusses languages used in mathematical reasoning, basic
concepts, and their properties and relationships among them. 
Though there is no time to cover them in this course, discrete mathematics
is also concerned with techniques to solve certain types of problems
such as how to count or enumerate quantities.
The kind of counting problems includes: How many routes exist from point A to point B
in a computer network ? How much execution time is required to sort
a list of integers in increasing order ? What is the probability of
winning a lottery ? What is the shortest path from point A to point B
in a computer network ? etc. 
<BR><BR>
The subjects covered in this course include propositional logic, predicate logic,
sets, relations, and functions, in particular growth of function.
<BR>
<BR>
The first subject is logic. It is covered in Chapter 1 of the textbook. It is a language 
that captures the essence of
our reasoning, and correct reasoning must follow the rules of this language. 
We start with logic of sentences
called propositional logic, and study elements of logic, (logical) relationships 
between propositions, and
reasoning. Then we learn a little more powerful logic called predicate logic. 
It allows us to reason with
statements involving variables among others. 

In Chapter 1 we also study sets, relations between sets, and operations on sets. 
Just about everything is
described based on sets, when rigor is required. It is the basis of every theory 
in computer science and
mathematics. 

In Chapter 3 we learn mathematical reasoning, in particular recursive definitions 
and mathematical induction. There are sets, operations and functions
that can be defined precisely by recursive definitions. Properties of those recursively 
defined objects can be
established rigorously using proof by induction. 

Then in Chapter 6 we study relations. They are an abstraction of relations we
are familiar with in everyday life such as husband-wife relation, parent-child relation and ownership relation. They are also one of the key concepts in the 
discussion 
of many subjects on
computer and computation. For example, a database is viewed as a set of relations 
and database query languages
are constructed based on operations on relations and sets. Graphs are also covered 
briefly here. They are an
example of discrete structures and they are one of the most useful models for computer scientists and
engineers in solving problems. More in-depth coverage of graph can be found in Chapter 7. 

Finally back in Chapter 1 we study functions and their asymptotic behaviors. 
Functions are a special type of
relation and basically the same kind of concept as the ones we see in calculus. 
However, function is one of the
most important concepts in the discussion of many subjects on computer and computation such as data
structures, database, formal languages and automata, and analysis of algorithms 
which is briefly covered in
Chapter 2. 
<BR><BR>
<BR>
Before we start the study of discrete structures, we briefly learn general framework 
of problem solving.
If you are a good problem solver, you may skip that and go to logic.
<B><a href="../problem_solving/problem_solving.html"><r><font color="blue">
<BR><BR>
<BR>
<B><a href="../problem_solving/problem_solving.html"><r><font color="blue">
Next -- Problem Solving Framework </font></r></a></B>
<BR>
<B><a href="../logic/intr_to_logic.html"><r><font color="blue">
Alternative -- Introduction to Logic </font></r></a></B>
<BR>
<BR>
<a href="../schedule/schedule.html#day1"><r><font color="blue">
Back to Schedule </font></r></a></B>
<BR>
<a href="../web_course.html"><r><font color="blue">
Back to Table of Contents </font></r></a></B>


</html>

<!-- Need a brief intro to prop logic and pred logic   -->
